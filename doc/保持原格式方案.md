# 如何保持原格式不变

## 问题分析

当前改写过程中格式丢失的原因：
1. **分段逻辑**：按 `\n\n+` 分割，丢失了单换行符
2. **合并逻辑**：用 `\n\n` 连接，改变了原有的换行方式
3. **AI输出**：AI可能会调整段落结构
4. **trim()操作**：去除了首尾空白字符

## 已实现的解决方案

### ✅ 方案1：保留原始分隔符（已实现）

#### 核心改进：

1. **记录原始分隔符**
```typescript
interface TextChunk {
  content: string;
  separator: string; // 记录原始分隔符（如 \n\n 或 \n\n\n）
  index: number;
}
```

2. **智能分段**
```typescript
// 使用正则捕获分隔符
const parts = text.split(/(\n\n+)/);
// 分别处理内容和分隔符
```

3. **原样重组**
```typescript
const finalResult = paraphrasedChunks
  .map((chunk, index) => chunk.content + chunk.separator)
  .join('');
```

4. **增强的Prompt**
```
【重要】严格保持原文的段落结构，有几个段落就输出几个段落
【重要】保持原文的换行位置，不要随意添加或删除换行符
如果原文某处有空行，改写后也要保留空行
```

### 效果对比

#### 修改前：
```
原文：
段落1

段落2


段落3

改写后：
段落1改写

段落2改写

段落3改写
```
❌ 丢失了原有的空行数量

#### 修改后：
```
原文：
段落1

段落2


段落3

改写后：
段落1改写

段落2改写


段落3改写
```
✅ 完全保持原有格式

## 进一步优化建议

### 方案2：保留更多格式信息

如果需要保留更复杂的格式（如缩进、列表等），可以：

#### 1. 标记特殊格式
```typescript
function markupFormat(text: string): string {
  return text
    .replace(/^(\s+)/gm, '<INDENT>$1</INDENT>') // 标记缩进
    .replace(/^(\d+\.\s)/gm, '<LIST_NUM>$1</LIST_NUM>') // 标记数字列表
    .replace(/^([•\-\*]\s)/gm, '<LIST_BULLET>$1</LIST_BULLET>'); // 标记符号列表
}
```

#### 2. 在Prompt中说明
```
原文中包含特殊标记：
- <INDENT>...</INDENT>: 表示缩进
- <LIST_NUM>...</LIST_NUM>: 表示数字列表
- <LIST_BULLET>...</LIST_BULLET>: 表示符号列表

改写时必须保留这些标记及其内容。
```

#### 3. 还原格式
```typescript
function restoreFormat(text: string): string {
  return text
    .replace(/<INDENT>(.*?)<\/INDENT>/g, '$1')
    .replace(/<LIST_NUM>(.*?)<\/LIST_NUM>/g, '$1')
    .replace(/<LIST_BULLET>(.*?)<\/LIST_BULLET>/g, '$1');
}
```

### 方案3：使用结构化数据

对于复杂文档，可以先解析成结构化数据：

```typescript
interface DocumentStructure {
  type: 'paragraph' | 'heading' | 'list' | 'quote';
  content: string;
  level?: number; // 标题级别或列表缩进
  format?: {
    indent: number;
    lineBreaks: number; // 后续空行数
  };
}

// 解析
function parseDocument(text: string): DocumentStructure[] {
  // 解析逻辑
}

// 改写每个部分
async function paraphraseStructured(doc: DocumentStructure[]): Promise<DocumentStructure[]> {
  // 只改写content，保留type和format
}

// 重建
function rebuildDocument(doc: DocumentStructure[]): string {
  // 按原格式重建
}
```

## 测试用例

### 测试1：多个空行
```
输入：
第一段

第二段


第三段

期望输出：保持1个、2个空行不变
```

### 测试2：缩进
```
输入：
正常段落
    缩进段落
正常段落

期望输出：保持缩进
```

### 测试3：列表
```
输入：
1. 第一项
2. 第二项
3. 第三项

期望输出：保持列表格式
```

## 使用建议

### 当前版本适用场景：
✅ 纯文本段落
✅ 不同数量的空行
✅ 基本的段落结构

### 需要进一步优化的场景：
⚠️ 缩进文本
⚠️ 列表（数字、符号）
⚠️ 引用块
⚠️ 代码块
⚠️ 表格

### 最佳实践：

1. **输入前检查**
   - 确保文本是纯文本格式
   - 避免复杂的格式（如表格、代码）

2. **分段大小**
   - 当前设置：2000字符/段
   - 可根据需要调整 `MAX_CHUNK_SIZE`

3. **验证输出**
   - 对比原文和改写后的段落数
   - 检查空行是否保持一致

4. **处理异常**
   - 如果AI没有保持格式，可以重试
   - 或者使用"轻度改写"模式（更保守）

## 技术细节

### 分隔符捕获
```typescript
// 使用捕获组保留分隔符
const parts = text.split(/(\n\n+)/);
// 结果：['段落1', '\n\n', '段落2', '\n\n\n', '段落3']
```

### 重组逻辑
```typescript
// 每个chunk带着自己的分隔符
chunks.map((chunk, index) => chunk.content + chunk.separator)
// 最后一个chunk的separator为空，避免多余换行
```

### Prompt优化
```typescript
// 在system和user消息中都强调格式保持
systemInstruction: "必须严格保持原文的段落结构和换行格式"
userPrompt: "【重要】保持原文的换行位置"
```

## 总结

✅ **已实现**：
- 保留原始空行数量
- 保持段落分隔符
- 增强Prompt指导AI保持格式

🔄 **可选优化**：
- 支持缩进和列表
- 支持更复杂的文档结构
- 添加格式验证和修复

💡 **建议**：
- 先测试当前版本是否满足需求
- 如需更复杂格式，再实现方案2或方案3
